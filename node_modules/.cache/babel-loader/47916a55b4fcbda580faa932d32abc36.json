{"ast":null,"code":"import TinyQueue from 'tinyqueue';\nimport Pathfinder from './Pathfinder';\nimport { NODE_WALL, WEIGHT_MAPPING } from '../constants';\nexport default class Dijkstra extends Pathfinder {\n  constructor() {\n    super(...arguments);\n    this.pq = new TinyQueue([], function (a, b) {\n      return a.g - b.g;\n    });\n  }\n\n  // Dijkstra is a variant of A* where the heuristic is zero\n  run() {\n    const {\n      pq,\n      dist,\n      closed,\n      prev,\n      board,\n      start,\n      finish,\n      updateNodeIsVisited,\n      delayedIteration\n    } = this;\n    let counter = 0;\n    if (start.x === finish.x && start.y === finish.y) {\n      return counter;\n    }\n    pq.push({\n      x: start.x,\n      y: start.y,\n      g: 0\n    });\n    dist[start.y][start.x] = 0;\n    while (pq.length) {\n      const current = pq.pop();\n      const currentX = current.x;\n      const currentY = current.y;\n      if (closed[currentY][currentX]) {\n        continue;\n      }\n      // Increment counter unless start node\n      if (!(currentX === start.x && currentY === start.y)) counter += 1;\n      closed[currentY][currentX] = true;\n      if (currentX === finish.x && currentY === finish.y) {\n        return this.traceShortestPath(counter);\n      }\n      // Don't visually update node-visited for start/finish nodes\n      if (!(currentX === start.x && currentY === start.y)) {\n        updateNodeIsVisited(currentY, currentX, true, counter * delayedIteration, delayedIteration);\n      }\n      for (let i = 0; i < Pathfinder.dx.length; ++i) {\n        const nextX = currentX + Pathfinder.dx[i];\n        const nextY = currentY + Pathfinder.dy[i];\n        if (nextX < 0 || nextX >= board[0].length || nextY < 0 || nextY >= board.length) {\n          continue;\n        }\n        if (closed[nextY][nextX]) {\n          continue;\n        }\n        if (board[nextY][nextX].type === NODE_WALL && !(nextX === finish.x && nextY === finish.y)) {\n          continue;\n        }\n        const weight = !(nextX === finish.x && nextY === finish.y) ? WEIGHT_MAPPING[board[nextY][nextX].type] : 1;\n        const g = dist[currentY][currentX] + weight;\n        // if there is a shorter path to nextPos\n        if (g < dist[nextY][nextX]) {\n          dist[nextY][nextX] = g;\n          prev[nextY][nextX] = {\n            x: currentX,\n            y: currentY\n          };\n          pq.push({\n            x: nextX,\n            y: nextY,\n            g\n          });\n        }\n      }\n    }\n    return counter;\n  }\n}","map":{"version":3,"names":["TinyQueue","Pathfinder","NODE_WALL","WEIGHT_MAPPING","Dijkstra","constructor","arguments","pq","a","b","g","run","dist","closed","prev","board","start","finish","updateNodeIsVisited","delayedIteration","counter","x","y","push","length","current","pop","currentX","currentY","traceShortestPath","i","dx","nextX","nextY","dy","type","weight"],"sources":["/home/sanyam/Desktop/PathFinding Visualizer/src/algorithms/Dijkstra.js"],"sourcesContent":["import TinyQueue from 'tinyqueue';\nimport Pathfinder from './Pathfinder';\nimport { NODE_WALL, WEIGHT_MAPPING } from '../constants';\n\nexport default class Dijkstra extends Pathfinder {\n  constructor(...args) {\n    super(...args);\n    this.pq = new TinyQueue([], function (a, b) {\n      return a.g - b.g;\n    });\n  }\n\n  // Dijkstra is a variant of A* where the heuristic is zero\n  run() {\n    const {\n      pq,\n      dist,\n      closed,\n      prev,\n      board,\n      start,\n      finish,\n      updateNodeIsVisited,\n      delayedIteration,\n    } = this;\n\n    let counter = 0;\n    if (start.x === finish.x && start.y === finish.y) {\n      return counter;\n    }\n\n    pq.push({ x: start.x, y: start.y, g: 0 });\n    dist[start.y][start.x] = 0;\n\n    while (pq.length) {\n      const current = pq.pop();\n      const currentX = current.x;\n      const currentY = current.y;\n\n      if (closed[currentY][currentX]) {\n        continue;\n      }\n      // Increment counter unless start node\n      if (!(currentX === start.x && currentY === start.y)) counter += 1;\n      closed[currentY][currentX] = true;\n      if (currentX === finish.x && currentY === finish.y) {\n        return this.traceShortestPath(counter);\n      }\n      // Don't visually update node-visited for start/finish nodes\n      if (!(currentX === start.x && currentY === start.y)) {\n        updateNodeIsVisited(\n          currentY,\n          currentX,\n          true,\n          counter * delayedIteration,\n          delayedIteration\n        );\n      }\n\n      for (let i = 0; i < Pathfinder.dx.length; ++i) {\n        const nextX = currentX + Pathfinder.dx[i];\n        const nextY = currentY + Pathfinder.dy[i];\n        if (\n          nextX < 0 ||\n          nextX >= board[0].length ||\n          nextY < 0 ||\n          nextY >= board.length\n        ) {\n          continue;\n        }\n        if (closed[nextY][nextX]) {\n          continue;\n        }\n        if (\n          board[nextY][nextX].type === NODE_WALL &&\n          !(nextX === finish.x && nextY === finish.y)\n        ) {\n          continue;\n        }\n\n        const weight = !(nextX === finish.x && nextY === finish.y)\n          ? WEIGHT_MAPPING[board[nextY][nextX].type]\n          : 1;\n        const g = dist[currentY][currentX] + weight;\n        // if there is a shorter path to nextPos\n        if (g < dist[nextY][nextX]) {\n          dist[nextY][nextX] = g;\n          prev[nextY][nextX] = { x: currentX, y: currentY };\n          pq.push({ x: nextX, y: nextY, g });\n        }\n      }\n    }\n    return counter;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}