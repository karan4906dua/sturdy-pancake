{"ast":null,"code":"import TinyQueue from 'tinyqueue';\nimport Pathfinder from './Pathfinder';\nimport { NODE_WALL, WEIGHT_MAPPING } from '../constants';\nexport default class AStar extends Pathfinder {\n  constructor() {\n    super(...arguments);\n    this.calculateHeuristic = (posX, posY) => {\n      return Math.abs(posX - this.finish.x) + Math.abs(posY - this.finish.y);\n    };\n    this.pq = new TinyQueue([], function (a, b) {\n      return a.f - b.f;\n    });\n  }\n\n  // Manhattan distance\n\n  run() {\n    const {\n      pq,\n      dist,\n      closed,\n      prev,\n      board,\n      start,\n      finish,\n      updateNodeIsVisited,\n      delayedIteration,\n      calculateHeuristic\n    } = this;\n    let counter = 0;\n    if (start.x === finish.x && start.y === finish.y) {\n      return counter;\n    }\n\n    // f = g + h, initial g is 0\n    const startF = calculateHeuristic(start.x, start.y);\n    pq.push({\n      x: start.x,\n      y: start.y,\n      f: startF\n    });\n    dist[start.y][start.x] = 0;\n    while (pq.length) {\n      const current = pq.pop();\n      const currentX = current.x;\n      const currentY = current.y;\n      if (closed[currentY][currentX]) {\n        continue;\n      }\n      // Increment counter unless start node\n      if (!(currentX === start.x && currentY === start.y)) counter += 1;\n      closed[currentY][currentX] = true;\n      if (currentX === finish.x && currentY === finish.y) {\n        return this.traceShortestPath(counter);\n      }\n      // Don't visually update node-visited for start/finish nodes\n      if (!(currentX === start.x && currentY === start.y)) {\n        updateNodeIsVisited(currentY, currentX, true, counter * delayedIteration, delayedIteration);\n      }\n      for (let i = 0; i < Pathfinder.dx.length; ++i) {\n        const nextX = currentX + Pathfinder.dx[i];\n        const nextY = currentY + Pathfinder.dy[i];\n        if (nextX < 0 || nextX >= board[0].length || nextY < 0 || nextY >= board.length) {\n          continue;\n        }\n        if (closed[nextY][nextX]) {\n          continue;\n        }\n        if (board[nextY][nextX].type === NODE_WALL && !(nextX === finish.x && nextY === finish.y)) {\n          continue;\n        }\n        const weight = !(nextX === finish.x && nextY === finish.y) ? WEIGHT_MAPPING[board[nextY][nextX].type] : 1;\n        const g = dist[currentY][currentX] + weight;\n        // f = g + h\n        const nextF = g + calculateHeuristic(nextX, nextY);\n        // if there is a shorter path to nextPos\n        if (g < dist[nextY][nextX]) {\n          dist[nextY][nextX] = g;\n          prev[nextY][nextX] = {\n            x: currentX,\n            y: currentY\n          };\n          pq.push({\n            x: nextX,\n            y: nextY,\n            f: nextF\n          });\n        }\n      }\n    }\n    return counter;\n  }\n}","map":{"version":3,"names":["TinyQueue","Pathfinder","NODE_WALL","WEIGHT_MAPPING","AStar","constructor","arguments","calculateHeuristic","posX","posY","Math","abs","finish","x","y","pq","a","b","f","run","dist","closed","prev","board","start","updateNodeIsVisited","delayedIteration","counter","startF","push","length","current","pop","currentX","currentY","traceShortestPath","i","dx","nextX","nextY","dy","type","weight","g","nextF"],"sources":["/home/sanyam/Desktop/PathFinding Visualizer/src/algorithms/AStar.js"],"sourcesContent":["import TinyQueue from 'tinyqueue';\nimport Pathfinder from './Pathfinder';\nimport { NODE_WALL, WEIGHT_MAPPING } from '../constants';\n\nexport default class AStar extends Pathfinder {\n  constructor(...args) {\n    super(...args);\n    this.pq = new TinyQueue([], function (a, b) {\n      return a.f - b.f;\n    });\n  }\n\n  // Manhattan distance\n  calculateHeuristic = (posX, posY) => {\n    return Math.abs(posX - this.finish.x) + Math.abs(posY - this.finish.y);\n  };\n\n  run() {\n    const {\n      pq,\n      dist,\n      closed,\n      prev,\n      board,\n      start,\n      finish,\n      updateNodeIsVisited,\n      delayedIteration,\n      calculateHeuristic,\n    } = this;\n\n    let counter = 0;\n    if (start.x === finish.x && start.y === finish.y) {\n      return counter;\n    }\n\n    // f = g + h, initial g is 0\n    const startF = calculateHeuristic(start.x, start.y);\n    pq.push({ x: start.x, y: start.y, f: startF });\n    dist[start.y][start.x] = 0;\n\n    while (pq.length) {\n      const current = pq.pop();\n      const currentX = current.x;\n      const currentY = current.y;\n\n      if (closed[currentY][currentX]) {\n        continue;\n      }\n      // Increment counter unless start node\n      if (!(currentX === start.x && currentY === start.y)) counter += 1;\n      closed[currentY][currentX] = true;\n      if (currentX === finish.x && currentY === finish.y) {\n        return this.traceShortestPath(counter);\n      }\n      // Don't visually update node-visited for start/finish nodes\n      if (!(currentX === start.x && currentY === start.y)) {\n        updateNodeIsVisited(\n          currentY,\n          currentX,\n          true,\n          counter * delayedIteration,\n          delayedIteration\n        );\n      }\n\n      for (let i = 0; i < Pathfinder.dx.length; ++i) {\n        const nextX = currentX + Pathfinder.dx[i];\n        const nextY = currentY + Pathfinder.dy[i];\n        if (\n          nextX < 0 ||\n          nextX >= board[0].length ||\n          nextY < 0 ||\n          nextY >= board.length\n        ) {\n          continue;\n        }\n        if (closed[nextY][nextX]) {\n          continue;\n        }\n        if (\n          board[nextY][nextX].type === NODE_WALL &&\n          !(nextX === finish.x && nextY === finish.y)\n        ) {\n          continue;\n        }\n\n        const weight = !(nextX === finish.x && nextY === finish.y)\n          ? WEIGHT_MAPPING[board[nextY][nextX].type]\n          : 1;\n        const g = dist[currentY][currentX] + weight;\n        // f = g + h\n        const nextF = g + calculateHeuristic(nextX, nextY);\n        // if there is a shorter path to nextPos\n        if (g < dist[nextY][nextX]) {\n          dist[nextY][nextX] = g;\n          prev[nextY][nextX] = { x: currentX, y: currentY };\n          pq.push({ x: nextX, y: nextY, f: nextF });\n        }\n      }\n    }\n\n    return counter;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}