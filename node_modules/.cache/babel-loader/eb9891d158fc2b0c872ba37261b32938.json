{"ast":null,"code":"import Denque from 'denque';\nimport Pathfinder from './Pathfinder';\nimport { NODE_WALL } from '../constants';\nexport default class DepthFirstSearch extends Pathfinder {\n  constructor() {\n    super(...arguments);\n    this.stk = new Denque();\n  }\n  run() {\n    const {\n      stk,\n      visited,\n      prev,\n      board,\n      start,\n      finish,\n      updateNodeIsVisited,\n      delayedIteration\n    } = this;\n    let counter = 0;\n    if (start.x === finish.x && start.y === finish.y) {\n      return counter;\n    }\n    stk.push({\n      x: start.x,\n      y: start.y\n    });\n    while (!stk.isEmpty()) {\n      const current = stk.pop();\n      const currentX = current.x;\n      const currentY = current.y;\n      if (visited[currentY][currentX]) {\n        continue;\n      }\n      // Increment counter unless start node\n      if (!(currentX === start.x && currentY === start.y)) counter += 1;\n      visited[currentY][currentX] = true;\n      if (currentX === finish.x && currentY === finish.y) {\n        return this.traceShortestPath(counter);\n      }\n      // Don't visually update node-visited for start/finish nodes\n      if (!(currentX === start.x && currentY === start.y)) {\n        updateNodeIsVisited(currentY, currentX, true, counter * delayedIteration, delayedIteration);\n      }\n      for (let i = 0; i < Pathfinder.dx.length; ++i) {\n        const nextX = current.x + Pathfinder.dx[i];\n        const nextY = current.y + Pathfinder.dy[i];\n        if (nextX < 0 || nextX >= board[0].length || nextY < 0 || nextY >= board.length) {\n          continue;\n        }\n        if (visited[nextY][nextX]) {\n          continue;\n        }\n        if (board[nextY][nextX].type === NODE_WALL && !(nextX === finish.x && nextY === finish.y)) {\n          continue;\n        }\n        prev[nextY][nextX] = {\n          x: current.x,\n          y: current.y\n        };\n        stk.push({\n          x: nextX,\n          y: nextY\n        });\n      }\n    }\n    return counter;\n  }\n}","map":{"version":3,"names":["Denque","Pathfinder","NODE_WALL","DepthFirstSearch","constructor","arguments","stk","run","visited","prev","board","start","finish","updateNodeIsVisited","delayedIteration","counter","x","y","push","isEmpty","current","pop","currentX","currentY","traceShortestPath","i","dx","length","nextX","nextY","dy","type"],"sources":["/home/sanyam/Desktop/PathFinding Visualizer/src/algorithms/DepthFirstSearch.js"],"sourcesContent":["import Denque from 'denque';\nimport Pathfinder from './Pathfinder';\nimport { NODE_WALL } from '../constants';\n\nexport default class DepthFirstSearch extends Pathfinder {\n  constructor(...args) {\n    super(...args);\n    this.stk = new Denque();\n  }\n\n  run() {\n    const {\n      stk,\n      visited,\n      prev,\n      board,\n      start,\n      finish,\n      updateNodeIsVisited,\n      delayedIteration,\n    } = this;\n\n    let counter = 0;\n    if (start.x === finish.x && start.y === finish.y) {\n      return counter;\n    }\n\n    stk.push({ x: start.x, y: start.y });\n    while (!stk.isEmpty()) {\n      const current = stk.pop();\n      const currentX = current.x;\n      const currentY = current.y;\n\n      if (visited[currentY][currentX]) {\n        continue;\n      }\n      // Increment counter unless start node\n      if (!(currentX === start.x && currentY === start.y)) counter += 1;\n      visited[currentY][currentX] = true;\n      if (currentX === finish.x && currentY === finish.y) {\n        return this.traceShortestPath(counter);\n      }\n      // Don't visually update node-visited for start/finish nodes\n      if (!(currentX === start.x && currentY === start.y)) {\n        updateNodeIsVisited(\n          currentY,\n          currentX,\n          true,\n          counter * delayedIteration,\n          delayedIteration\n        );\n      }\n\n      for (let i = 0; i < Pathfinder.dx.length; ++i) {\n        const nextX = current.x + Pathfinder.dx[i];\n        const nextY = current.y + Pathfinder.dy[i];\n        if (\n          nextX < 0 ||\n          nextX >= board[0].length ||\n          nextY < 0 ||\n          nextY >= board.length\n        ) {\n          continue;\n        }\n        if (visited[nextY][nextX]) {\n          continue;\n        }\n        if (\n          board[nextY][nextX].type === NODE_WALL &&\n          !(nextX === finish.x && nextY === finish.y)\n        ) {\n          continue;\n        }\n\n        prev[nextY][nextX] = { x: current.x, y: current.y };\n        stk.push({ x: nextX, y: nextY });\n      }\n    }\n    return counter;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}