{"ast":null,"code":"import Denque from 'denque';\nimport Pathfinder from './Pathfinder';\nimport { NODE_WALL } from '../constants';\nexport default class BreadthFirstSearch extends Pathfinder {\n  constructor() {\n    super(...arguments);\n    this.q = new Denque();\n  }\n  run() {\n    const {\n      q,\n      visited,\n      prev,\n      board,\n      start,\n      finish,\n      updateNodeIsVisited,\n      delayedIteration\n    } = this;\n    let counter = 0;\n    if (start.x === finish.x && start.y === finish.y) {\n      return counter;\n    }\n    q.push({\n      x: start.x,\n      y: start.y\n    });\n    visited[start.y][start.x] = true;\n    while (!q.isEmpty()) {\n      const current = q.shift();\n      for (let i = 0; i < Pathfinder.dx.length; ++i) {\n        const nextX = current.x + Pathfinder.dx[i];\n        const nextY = current.y + Pathfinder.dy[i];\n        if (nextX < 0 || nextX >= board[0].length || nextY < 0 || nextY >= board.length) {\n          continue;\n        }\n        if (visited[nextY][nextX]) {\n          continue;\n        }\n        if (board[nextY][nextX].type === NODE_WALL && !(nextX === finish.x && nextY === finish.y)) {\n          continue;\n        }\n        counter += 1;\n        visited[nextY][nextX] = true;\n        prev[nextY][nextX] = {\n          x: current.x,\n          y: current.y\n        };\n        if (nextX === finish.x && nextY === finish.y) {\n          return this.traceShortestPath(counter);\n        }\n        updateNodeIsVisited(nextY, nextX, true, counter * delayedIteration, delayedIteration);\n        q.push({\n          x: nextX,\n          y: nextY\n        });\n      }\n    }\n    return counter;\n  }\n}","map":{"version":3,"names":["Denque","Pathfinder","NODE_WALL","BreadthFirstSearch","constructor","arguments","q","run","visited","prev","board","start","finish","updateNodeIsVisited","delayedIteration","counter","x","y","push","isEmpty","current","shift","i","dx","length","nextX","nextY","dy","type","traceShortestPath"],"sources":["/home/sanyam/Desktop/PathFinding Visualizer/src/algorithms/BreadthFirstSearch.js"],"sourcesContent":["import Denque from 'denque';\nimport Pathfinder from './Pathfinder';\nimport { NODE_WALL } from '../constants';\n\nexport default class BreadthFirstSearch extends Pathfinder {\n  constructor(...args) {\n    super(...args);\n    this.q = new Denque();\n  }\n\n  run() {\n    const {\n      q,\n      visited,\n      prev,\n      board,\n      start,\n      finish,\n      updateNodeIsVisited,\n      delayedIteration,\n    } = this;\n\n    let counter = 0;\n    if (start.x === finish.x && start.y === finish.y) {\n      return counter;\n    }\n\n    q.push({ x: start.x, y: start.y });\n    visited[start.y][start.x] = true;\n    while (!q.isEmpty()) {\n      const current = q.shift();\n\n      for (let i = 0; i < Pathfinder.dx.length; ++i) {\n        const nextX = current.x + Pathfinder.dx[i];\n        const nextY = current.y + Pathfinder.dy[i];\n        if (\n          nextX < 0 ||\n          nextX >= board[0].length ||\n          nextY < 0 ||\n          nextY >= board.length\n        ) {\n          continue;\n        }\n        if (visited[nextY][nextX]) {\n          continue;\n        }\n        if (\n          board[nextY][nextX].type === NODE_WALL &&\n          !(nextX === finish.x && nextY === finish.y)\n        ) {\n          continue;\n        }\n\n        counter += 1;\n        visited[nextY][nextX] = true;\n        prev[nextY][nextX] = { x: current.x, y: current.y };\n        if (nextX === finish.x && nextY === finish.y) {\n          return this.traceShortestPath(counter);\n        }\n        updateNodeIsVisited(\n          nextY,\n          nextX,\n          true,\n          counter * delayedIteration,\n          delayedIteration\n        );\n\n        q.push({ x: nextX, y: nextY });\n      }\n    }\n    return counter;\n  }\n}\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,QAAQ;AAC3B,OAAOC,UAAU,MAAM,cAAc;AACrC,SAASC,SAAS,QAAQ,cAAc;AAExC,eAAe,MAAMC,kBAAkB,SAASF,UAAU,CAAC;EACzDG,WAAWA,CAAA,EAAU;IACnB,KAAK,CAAC,GAAAC,SAAO,CAAC;IACd,IAAI,CAACC,CAAC,GAAG,IAAIN,MAAM,EAAE;EACvB;EAEAO,GAAGA,CAAA,EAAG;IACJ,MAAM;MACJD,CAAC;MACDE,OAAO;MACPC,IAAI;MACJC,KAAK;MACLC,KAAK;MACLC,MAAM;MACNC,mBAAmB;MACnBC;IACF,CAAC,GAAG,IAAI;IAER,IAAIC,OAAO,GAAG,CAAC;IACf,IAAIJ,KAAK,CAACK,CAAC,KAAKJ,MAAM,CAACI,CAAC,IAAIL,KAAK,CAACM,CAAC,KAAKL,MAAM,CAACK,CAAC,EAAE;MAChD,OAAOF,OAAO;IAChB;IAEAT,CAAC,CAACY,IAAI,CAAC;MAAEF,CAAC,EAAEL,KAAK,CAACK,CAAC;MAAEC,CAAC,EAAEN,KAAK,CAACM;IAAE,CAAC,CAAC;IAClCT,OAAO,CAACG,KAAK,CAACM,CAAC,CAAC,CAACN,KAAK,CAACK,CAAC,CAAC,GAAG,IAAI;IAChC,OAAO,CAACV,CAAC,CAACa,OAAO,EAAE,EAAE;MACnB,MAAMC,OAAO,GAAGd,CAAC,CAACe,KAAK,EAAE;MAEzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,UAAU,CAACsB,EAAE,CAACC,MAAM,EAAE,EAAEF,CAAC,EAAE;QAC7C,MAAMG,KAAK,GAAGL,OAAO,CAACJ,CAAC,GAAGf,UAAU,CAACsB,EAAE,CAACD,CAAC,CAAC;QAC1C,MAAMI,KAAK,GAAGN,OAAO,CAACH,CAAC,GAAGhB,UAAU,CAAC0B,EAAE,CAACL,CAAC,CAAC;QAC1C,IACEG,KAAK,GAAG,CAAC,IACTA,KAAK,IAAIf,KAAK,CAAC,CAAC,CAAC,CAACc,MAAM,IACxBE,KAAK,GAAG,CAAC,IACTA,KAAK,IAAIhB,KAAK,CAACc,MAAM,EACrB;UACA;QACF;QACA,IAAIhB,OAAO,CAACkB,KAAK,CAAC,CAACD,KAAK,CAAC,EAAE;UACzB;QACF;QACA,IACEf,KAAK,CAACgB,KAAK,CAAC,CAACD,KAAK,CAAC,CAACG,IAAI,KAAK1B,SAAS,IACtC,EAAEuB,KAAK,KAAKb,MAAM,CAACI,CAAC,IAAIU,KAAK,KAAKd,MAAM,CAACK,CAAC,CAAC,EAC3C;UACA;QACF;QAEAF,OAAO,IAAI,CAAC;QACZP,OAAO,CAACkB,KAAK,CAAC,CAACD,KAAK,CAAC,GAAG,IAAI;QAC5BhB,IAAI,CAACiB,KAAK,CAAC,CAACD,KAAK,CAAC,GAAG;UAAET,CAAC,EAAEI,OAAO,CAACJ,CAAC;UAAEC,CAAC,EAAEG,OAAO,CAACH;QAAE,CAAC;QACnD,IAAIQ,KAAK,KAAKb,MAAM,CAACI,CAAC,IAAIU,KAAK,KAAKd,MAAM,CAACK,CAAC,EAAE;UAC5C,OAAO,IAAI,CAACY,iBAAiB,CAACd,OAAO,CAAC;QACxC;QACAF,mBAAmB,CACjBa,KAAK,EACLD,KAAK,EACL,IAAI,EACJV,OAAO,GAAGD,gBAAgB,EAC1BA,gBAAgB,CACjB;QAEDR,CAAC,CAACY,IAAI,CAAC;UAAEF,CAAC,EAAES,KAAK;UAAER,CAAC,EAAES;QAAM,CAAC,CAAC;MAChC;IACF;IACA,OAAOX,OAAO;EAChB;AACF"},"metadata":{},"sourceType":"module"}